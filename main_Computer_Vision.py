#################################################
#####    Guillem Cornella, November 2021    #####
##### The code has the following structure: #####

# · Obtain the frames from an IP Camera
# · Segment the frames to extract just the red colors
# · Apply an opening to eliminate blobs generated by a bad red segmentation
# · Extract the corners from the detected red object
# · Plot a rectangle on top of the image frames containing the red object
# · Plot the position of the centroid, and the width and height of the object
################################################
''' Libraries '''
import cv2
import numpy as np

# This function will generate a box containing the desired information
def __draw_label(img, text, pos, bg_color):
    font_face = cv2.FONT_HERSHEY_SIMPLEX
    scale = 0.5
    color = (0, 0, 0)
    thickness = cv2.FILLED
    margin = 5
    txt_size = cv2.getTextSize(text, font_face, scale, thickness)
    end_x = pos[0] + txt_size[0][0] + margin
    end_y = pos[1] - txt_size[0][1] - margin

    cv2.rectangle(img, pos, (end_x, end_y), bg_color, thickness)
    cv2.putText(img, text, pos, font_face, scale, color, 1, cv2.LINE_AA)
# This function will segment the image by color and will create a mask with just the red objects
def color_segmentation(img):
    # img = cv2.imread("capture1.png")
    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    ## Gen lower mask (0-5) and upper mask (175-180) of RED
    mask1 = cv2.inRange(img_hsv, (0, 50, 20), (5, 255, 255))
    mask2 = cv2.inRange(img_hsv, (175, 50, 20), (180, 255, 255))
    ## Merge the mask and crop the red regions
    mask = cv2.bitwise_or(mask1, mask2)
    #cropped = cv2.bitwise_and(img, img, mask=mask)
    return mask
# This function will perform a morphological operation to eliminate blobs by Opening the binary mask
def image_opening(img):
    # Generate a morphological opening (an erosion followed by a dilation).
    kernelSize = [20,20]    # (3, 3), (5, 5), (7, 7)
    # loop over the kernels sizes
    #for kernelSize in kernelSizes:
        # construct a rectangular kernel from the current size and then
        # apply an "opening" operation
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, kernelSize)
    opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)
    return opening
# This function will return the corners of a binary object
def get_corners(img):
    contours, hierarchy = cv2.findContours(img, 1, 2)
    print(contours)
    if not(contours):
        cnt = ([0,0])
        x = [0, 0]
        y = [0, 0]
        w = 0
        h = 0
        cX = 0
        cY = 0
    else:
        cnt = contours[0]
        # Coordinates of the Centroid
        M = cv2.moments(cnt)
        cX = int(M["m10"] / M["m00"])
        cY = int(M["m01"] / M["m00"])

        x, y, w, h = cv2.boundingRect(cnt)

    return x,y,w,h,cnt,cX,cY

########### MAIN ###############
''' Image acquisition from an IP camera, Install IP Camera application and click on start server'''
cap = cv2.VideoCapture('http://your_ip:8080/video')        # change for the IP shown in your screen

c = 0 # loop counter
while(True):
    ret, frame = cap.read() # ret is a boolean variable that returns true if the frame is available.
                            # frame is an image array vector captured based on the default frames per second defined explicitly or implicitly
    if ret == True:
        red_image_mask = color_segmentation(frame)
        opened_image = image_opening(red_image_mask)
        # cropped = cv2.bitwise_and(frame, frame, mask=opened_image)
        x,y,w,h,corners,cX,cY = get_corners(opened_image)

        if (w != 0):
            mask_rect = cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
            __draw_label(frame, 'Robot Learning:', (20, 390), (255, 255, 255))
            __draw_label(frame, 'Width:'+str(np.array([w]))+'Height:'+str(np.array([h])), (20, 410), (255, 255, 255))
            __draw_label(frame, 'Center_X:' + str(cX) + 'Center_Y:' + str(cY), (20, 430),(255, 255, 255))
            __draw_label(frame, 'Loops' + str(c), (20, 450), (255, 255, 255))
            cv2.imshow('final_image', mask_rect)
        else:
            __draw_label(frame, 'No object detected', (20, 410),(255, 255, 255))
            cv2.imshow('final_image', frame)

    c += 1 # increase counter
    # Take a snapshot every 200 iterations and save the image with the values w,h,cX and cY
    # This images could be then used to train the simulation
    if (c==200):
        cv2.imwrite('w' + str(w) + 'h'+ str(h) + 'cX' + str(cX) + 'cY' + str(cY) + '.jpg', frame)
        c = 0

    # close the screen
    k = cv2.waitKey(5) & 0xff
    # Press the 'esc' key to close the webcam
    if k == 27:
        break
